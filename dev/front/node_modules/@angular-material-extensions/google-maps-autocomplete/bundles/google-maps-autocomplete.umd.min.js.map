{"version":3,"file":"google-maps-autocomplete.umd.min.js","sources":["../../tmp/module/directives/address-validator/mat-address-validator.directive.ts","../../tmp/module/component/mat-google-maps-autocomplete.component.ts","../../tmp/module/directives/mat-google-maps-autocomplete.directive.ts","../../tmp/module/mat-google-maps-autocomplete.module.ts"],"sourcesContent":["import {Directive, EventEmitter, forwardRef} from '@angular/core';\nimport {AbstractControl, NG_VALIDATORS, ValidationErrors, Validator, ValidatorFn} from '@angular/forms';\nimport PlaceResult = google.maps.places.PlaceResult;\n\n// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts\n\n@Directive({\n  selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',\n  providers: [\n    {provide: NG_VALIDATORS, useExisting: forwardRef(() => MatValidateAddressDirective), multi: true}\n  ]\n})\nexport class MatValidateAddressDirective implements Validator {\n\n  public subscription: any;\n\n  private _address: PlaceResult;\n\n\n  constructor() {\n  }\n\n  public validate(): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | any => {\n      return this.address ? null : {\n        validateAddress: {\n          valid: false\n        }\n      };\n    }\n  }\n\n  public subscribe(eventEmitter: EventEmitter<any>) {\n    this.subscription = eventEmitter.subscribe((address: PlaceResult) => {\n      this.address = address;\n    });\n  }\n\n  public unsubscribe() {\n    this.subscription.unsubscribe();\n  }\n\n  get address() {\n    return this._address;\n  }\n\n  set address(value) {\n    this._address = value;\n  }\n}\n","import {Component, ElementRef, EventEmitter, Input, NgZone, OnInit, Output, ViewChild} from '@angular/core';\nimport {FormControl, Validators} from '@angular/forms';\nimport {MapsAPILoader} from '@agm/core';\nimport {MatValidateAddressDirective} from '../directives/address-validator/mat-address-validator.directive';\nimport {Location} from '../interfaces/location.interface';\nimport PlaceResult = google.maps.places.PlaceResult;\nimport AutocompleteOptions = google.maps.places.AutocompleteOptions;\n\nexport enum Appearance {\n  STANDARD = 'standard',\n  FILL = 'fill',\n  OUTLINE = 'outline',\n  LEGACY = 'legacy',\n}\n\n@Component({\n  selector: 'mat-google-maps-autocomplete',\n  exportAs: 'matGoogleMapsAutocomplete',\n  template: `\n    <mat-form-field class=\"full-width\" [appearance]=\"appearance\">\n      <mat-label>{{addressLabelText}}</mat-label>\n      <input matInput\n             [(ngModel)]=\"address\"\n             (change)=\"onQuery($event)\"\n             placeholder=\"{{placeholderText}}\"\n             class=\"form-control\"\n             #search\n             MatValidateAddress\n             required>\n      <mat-error *ngIf=\"addressSearchControl.hasError('required')\">\n        {{requiredErrorText}}\n      </mat-error>\n      <mat-error *ngIf=\"addressSearchControl.hasError('validateAddress')\">\n        {{invalidErrorText}}\n      </mat-error>\n    </mat-form-field>\n  `,\n  styles: [`\n    .full-width{width:100%}\n  `]\n})\nexport class MatGoogleMapsAutocompleteComponent implements OnInit {\n\n  @ViewChild('search')\n  public searchElementRef: ElementRef;\n\n  @Input()\n  addressLabelText = 'Address';\n\n  @Input()\n  placeholderText = 'Please enter the address';\n\n  @Input()\n  requiredErrorText = 'The address is required';\n\n  @Input()\n  invalidErrorText = 'The address is not valid';\n\n  @Input()\n  appearance: string | Appearance = Appearance.STANDARD;\n\n  @Input()\n  address: PlaceResult | string;\n\n  @Input()\n  country: string | string[];\n\n  @Input()\n  placeIdOnly?: boolean;\n\n  @Input()\n  strictBounds?: boolean;\n\n  @Input()\n  types?: string[];\n  // types: string[] = ['address'];\n\n  @Input()\n  type?: string;\n\n  @Input()\n  autoCompleteOptions: AutocompleteOptions = {};\n\n  @Output()\n  onChange: EventEmitter<PlaceResult | string | null> = new EventEmitter<PlaceResult | string | null>();\n\n  @Output()\n  onAutocompleteSelected: EventEmitter<PlaceResult> = new EventEmitter<PlaceResult>();\n\n  @Output()\n  onLocationSelected: EventEmitter<Location> = new EventEmitter<Location>();\n\n  private onNewPlaceResult: EventEmitter<any> = new EventEmitter();\n  private addressValidator: MatValidateAddressDirective = new MatValidateAddressDirective();\n\n  public addressSearchControl: FormControl = new FormControl({value: null}, Validators.compose([\n    Validators.required,\n    this.addressValidator.validate()])\n  );\n\n  constructor(private _mapsAPILoader: MapsAPILoader,\n              private _ngZone: NgZone) {\n  }\n\n  ngOnInit(): void {\n    this.addressValidator.subscribe(this.onNewPlaceResult);\n\n    const options = {\n      // types: ['address'],\n      componentRestrictions: {country: this.country},\n      placeIdOnly: this.placeIdOnly,\n      strictBounds: this.strictBounds,\n      types: this.types,\n      type: this.type\n    };\n\n    this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n    this.initGoogleMapsAutocomplete();\n  }\n\n  public initGoogleMapsAutocomplete() {\n    this._mapsAPILoader\n      .load()\n      .then(() => {\n        const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);\n        autocomplete.addListener('place_changed', () => {\n          this._ngZone.run(() => {\n            // get the place result\n            const place: PlaceResult = autocomplete.getPlace();\n\n            if (!place.place_id || place.geometry === undefined || place.geometry === null) {\n              // place result is not valid\n              return;\n            } else {\n              // show dialog to select a address from the input\n              // emit failed event\n            }\n            this.address = place.formatted_address;\n            this.onAutocompleteSelected.emit(place);\n            // console.log('onAutocompleteSelected -> ', place);\n            this.onLocationSelected.emit(\n              {\n                latitude: place.geometry.location.lat(),\n                longitude: place.geometry.location.lng()\n              })\n          });\n        });\n      })\n      .catch((err) => console.log(err));\n  }\n\n  public onQuery(event: any) {\n    // console.log('onChange()', event);\n    this.onChange.emit(this.address);\n  }\n\n  private resetAddress() {\n    this.address = null;\n    this.addressSearchControl.updateValueAndValidity();\n  }\n\n}\n","import {Directive, ElementRef, EventEmitter, Inject, Input, NgZone, OnInit, Output, PLATFORM_ID} from '@angular/core';\nimport {FormControl, Validators} from '@angular/forms';\nimport {MatValidateAddressDirective} from '../directives/address-validator/mat-address-validator.directive';\nimport {MapsAPILoader} from '@agm/core';\nimport {Location} from '../interfaces/location.interface';\nimport PlaceResult = google.maps.places.PlaceResult;\nimport AutocompleteOptions = google.maps.places.AutocompleteOptions;\nimport {isPlatformBrowser} from '@angular/common';\n\n@Directive({\n  selector: '[matGoogleMapsAutocomplete]',\n  exportAs: 'matGoogleMapsAutocomplete',\n})\nexport class MatGoogleMapsAutocompleteDirective implements OnInit {\n\n  @Input()\n  address: PlaceResult | string;\n\n  @Input()\n  country: string | string[];\n\n  @Input()\n  placeIdOnly?: boolean;\n\n  @Input()\n  strictBounds?: boolean;\n\n  @Input()\n  types?: string[];\n\n  @Input()\n  type?: string;\n\n  @Input()\n  autoCompleteOptions: AutocompleteOptions = {};\n\n  @Output()\n  onChange: EventEmitter<PlaceResult | string | null> = new EventEmitter<PlaceResult | string | null>();\n\n  @Output()\n  onAutocompleteSelected: EventEmitter<PlaceResult> = new EventEmitter<PlaceResult>();\n\n  @Output()\n  onLocationSelected: EventEmitter<Location> = new EventEmitter<Location>();\n\n  private onNewPlaceResult: EventEmitter<any> = new EventEmitter();\n  private addressValidator: MatValidateAddressDirective = new MatValidateAddressDirective();\n\n  public addressSearchControl: FormControl = new FormControl({value: null}, Validators.compose([\n    Validators.required,\n    this.addressValidator.validate()])\n  );\n\n  constructor(@Inject(PLATFORM_ID) public platformId: string,\n              public elemRef: ElementRef,\n              public mapsAPILoader: MapsAPILoader,\n              private _ngZone: NgZone) {\n  }\n\n  ngOnInit(): void {\n    if (isPlatformBrowser(this.platformId)) {\n      this.addressValidator.subscribe(this.onNewPlaceResult);\n      const options = {\n        // types: ['address'],\n        componentRestrictions: {country: this.country},\n        placeIdOnly: this.placeIdOnly,\n        strictBounds: this.strictBounds,\n        types: this.types,\n        type: this.type\n      };\n\n      this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n      this.initGoogleMapsAutocomplete();\n    }\n\n  }\n\n  public initGoogleMapsAutocomplete() {\n    this.mapsAPILoader\n      .load()\n      .then(() => {\n        const autocomplete = new google.maps.places.Autocomplete(this.elemRef.nativeElement, this.autoCompleteOptions);\n        autocomplete.addListener('place_changed', () => {\n          this._ngZone.run(() => {\n            // get the place result\n            const place: PlaceResult = autocomplete.getPlace();\n\n            if (!place.place_id || place.geometry === undefined || place.geometry === null) {\n              // place result is not valid\n              return;\n            } else {\n              // show dialog to select a address from the input\n              // emit failed event\n            }\n            this.address = place.formatted_address;\n            this.onAutocompleteSelected.emit(place);\n            this.onLocationSelected.emit(\n              {\n                latitude: place.geometry.location.lat(),\n                longitude: place.geometry.location.lng()\n              })\n          });\n        });\n      })\n      .catch((err) => console.log(err));\n  }\n\n}\n","import {CommonModule} from '@angular/common';\nimport {ModuleWithProviders, NgModule} from '@angular/core';\n\nimport {MatGoogleMapsAutocompleteComponent} from './component/mat-google-maps-autocomplete.component';\nimport {MatInputModule} from '@angular/material';\nimport {FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport {MatValidateAddressDirective} from './directives/address-validator/mat-address-validator.directive';\nimport {MatGoogleMapsAutocompleteDirective} from './directives/mat-google-maps-autocomplete.directive';\n\n// Export module's public API\nexport {MatGoogleMapsAutocompleteComponent, Appearance} from './component/mat-google-maps-autocomplete.component';\nexport {MatValidateAddressDirective} from './directives/address-validator/mat-address-validator.directive';\nexport {MatGoogleMapsAutocompleteDirective} from './directives/mat-google-maps-autocomplete.directive';\nexport {Location} from './interfaces/location.interface';\n\n// export {MatValidateAddressDirective} from './directives/address-validator/mat-address-validator.directive';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    FormsModule,\n    ReactiveFormsModule,\n    MatInputModule\n  ],\n  exports: [\n    MatGoogleMapsAutocompleteComponent,\n    MatGoogleMapsAutocompleteDirective,\n    MatValidateAddressDirective\n  ],\n  declarations: [\n    MatGoogleMapsAutocompleteComponent,\n    MatGoogleMapsAutocompleteDirective,\n    MatValidateAddressDirective\n  ]\n})\nexport class MatGoogleMapsAutocompleteModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: MatGoogleMapsAutocompleteModule,\n      providers: []\n    };\n  }\n}\n"],"names":["MatValidateAddressDirective","control","_this","address","validateAddress","valid","eventEmitter","this","subscription","subscribe","unsubscribe","Object","_address","value","Directive","selector","providers","provide","NG_VALIDATORS","useExisting","forwardRef","multi","STANDARD","FILL","OUTLINE","LEGACY","_mapsAPILoader","_ngZone","Appearance","EventEmitter","FormControl","Validators","compose","required","addressValidator","validate","MatGoogleMapsAutocompleteComponent","onNewPlaceResult","options","componentRestrictions","country","placeIdOnly","strictBounds","types","type","autoCompleteOptions","assign","initGoogleMapsAutocomplete","load","then","autocomplete","google","maps","places","Autocomplete","searchElementRef","nativeElement","addListener","run","place","getPlace","place_id","undefined","geometry","formatted_address","onAutocompleteSelected","emit","onLocationSelected","latitude","location","lat","longitude","lng","catch","err","console","log","event","onChange","addressSearchControl","updateValueAndValidity","Component","exportAs","template","styles","MapsAPILoader","NgZone","ViewChild","Input","Output","platformId","elemRef","mapsAPILoader","MatGoogleMapsAutocompleteDirective","isPlatformBrowser","Inject","PLATFORM_ID","ElementRef","MatGoogleMapsAutocompleteModule","ngModule","NgModule","imports","CommonModule","FormsModule","ReactiveFormsModule","MatInputModule","exports","declarations"],"mappings":"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"}